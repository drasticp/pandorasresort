import {LitElement, html, css} from 'lit';

var sharedStyle = css`
    label { display:block; }
    label, th { font:var(--label-font); background:var(--label-background); color:var(--label-inverse);padding:var(--label-padding); text-transform:var(--label-text-transform); }
    input, textarea { font:var(--input-font); width:100%; color:var(--input-inverse); border:var(--input-border); padding:var(--input-padding); box-sizing:border-box; border-radius:var(--input-radius); box-shadow:none; font-size:var(--input-font-size); font-weight:var(--input-font-weight);  -webkit-appearance: none; -moz-appearance: none; appearance: none; }
    input, textarea { -webkit-appearance: none; -moz-appearance: none; appearance: none; } /* remove ios inset shadow */
    input:focus, textarea:focus { outline:none; }
    input:invalid { border: 1px solid var(--alert-color); }
    input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    ::placeholder { color:var(--input-inverse); opacity:0.6; }
`;

export class ResizeController {
    host; 

    constructor(host) {
        this.host = host;
        host.addController(this);
        this.resize = this.resize.bind(this);
    }

    hostConnected() {
        window.addEventListener('resize', this.resize);
        this.resize();
    }
    
    hostDisconnected() {
        window.removeEventListener('resize', this.resize);
    }

    resize() {
        if(window.innerWidth < 460) {
            this.host.classList.add("mobile");
            this.host.classList.remove("desktop");
        } else {
            this.host.classList.add("desktop");
            this.host.classList.remove("mobile");
        }
        if(this.host.onResized) this.host.onResized(window.innerWidth);
    }
}

export class Bouncer {
    static debounce(context, func, wait) {
        if(func.timeoutId != undefined) window.clearTimeout(func.timeoutId);
        func.timeoutId = setTimeout(function() {
            func.apply(context);
        }, wait);
    };
}

export class Clipboard {
    static copyElement(element) {
        let selection = window.getSelection();
        selection.removeAllRanges();
        let range = document.createRange();
        range.selectNode(element);
        selection.addRange(range);
        let successful = document.execCommand('copy');
        selection.removeAllRanges();
        return successful;
    }

    static copyText(text) {
        let e = document.createElement("div");
        document.body.appendChild(e);
        e.innerText = text; 
        console.log("copying", e);
        this.copyElement(e);
        document.body.removeChild(e);
        return true;
    }
}

export class DateUtil {

    static formatShort(date) {
        var options = { year: 'numeric', month: '2-digit', day: '2-digit' };
        return new Date(date).toLocaleDateString("en-US", options); 
    }

    static formatWkMoDay(date) {
        var options = {weekday: 'short', month: 'short', day: '2-digit' };
        return new Date(date).toLocaleDateString("en-US", options); 
    }

    static formatMoDay(date) {
        var options = {month: 'short', day: '2-digit' };
        return new Date(date).toLocaleDateString("en-US", options); 
    }

    static formatLong(date) {
        var options = { weekday: 'long', year: 'numeric', month: 'long', day: '2-digit' };
        return new Date(date).toLocaleDateString("en-US", options);
    }

    static formatWithTime(date) {
        var dateopts = { year: 'numeric', month: '2-digit', day: '2-digit' };
        let timeopts = { hour: '2-digit', minute: '2-digit' };
        let val = new Date(date);
        return val.toLocaleDateString("en-US", dateopts) + " " +  date.toLocaleTimeString([], timeopts);
    }

    static formatMedium(date) {
        var options = { weekday: 'short', month: 'short', day: '2-digit', year: 'numeric' };
        return new Date(date).toLocaleDateString("en-US", options);        
    }

    static dayDiff(date1, date2) {
        var d1 = new Date(date1);
        var d2 = new Date(date2);
        var diff = d1 - d2; 
        var days = Math.round(diff / (1000 * 60 * 60 * 24));
        return days;
    }

    static formatDayDiff(date1, date2) {
        var diff = DateUtil.dayDiff(date2, date1);
        return (diff == 1) ? diff + " night" : diff + " nights";
    }

    static firstOfWeek(date) {
        var fow = new Date(date);
        fow.setDate(fow.getDate() - fow.getDay());
        return fow;
    }

    static firstOfMonth(date) {
        var fom = new Date(date);
        fom.setDate(1);
        return fom; 
    }
}

export class BrightNav extends LitElement {   
    resizer = new ResizeController(this);

    static styles = css`
        :host { display:block; justify-content:space-between; width:100%; max-width:var(--content-width); margin:auto; display:flex; align-items:center; }
        :host([hidden]) { display:none; }
        #overlay { position:absolute; z-index:100; flex-direction:column; align-items:center; gap:16px; display:none; height:100%; width:100%; top:0px; left:0px; background:var(--body-inverse); fill:var(--body-background); color:var(--body-background); } 
        #clearicon { align-self:flex-start; margin:16px 16px 0px 16px; fill:inherit;  }
        #menuicon { position:absolute; left:16px; fill:var(--background-inverse); }
        #main { width:100%; display:flex; align-items:center; justify-content:center; }
        ::slotted(*) { color:inherit; fill:inherit; background:inherit; }
        #main ::slotted(img) { padding:24px; }
    `;

    static properties = {
        width: { type:Number }
    };

    render() {
        var menu = html``;
        if(this.width < 460) {
            return html`
            <div id="main" part="main">
                <bright-icon id="menuicon" icon="menu" @click="${this.menuIconClick}"></bright-icon>
                <slot name="logo"></slot>
            </div>
            <div id="overlay" part="overlay">
                <bright-icon id="clearicon" icon="clear" @click="${this.closeIconClick}"></bright-icon>
                <slot @click="${this.menuItemClick}"></slot>
            </div>
            `;
        } else {
            return html`
                <slot name="logo" part="logo"></slot>
                <slot @click="${this.menuItemClick}"></slot>
            `;
        }
    }

    firstUpdated() {
        this.overlay = this.renderRoot.querySelector("#overlay");
    }

    onResized(width) {
        this.width = width;
    }

    menuItemClick() {
        this.closeIconClick();
    }

    menuIconClick() {
        this.overlay.style.display = "flex";
        this.overlay.animate([ 
            { transform:'translateY(-50%)', opacity:0 },
            { transform:'translateY(0)', opacity:1 } 
        ], { duration:300, easing:'ease-out', fill: 'both' } );
    }
    closeIconClick() {
        this.overlay.animate([ 
            { transform:'translateY(0)', opacity:1 },
            { transform:'translateY(-50%)', opacity:0 } 
        ], { duration:300, easing:'ease-out', fill: 'both' } ).onfinish = () => {
            this.overlay.style.display = "none";
        };
    }
}
window.customElements.define("bright-nav", BrightNav);

export class BrightIcon extends LitElement {

    static get properties() {
        return {
            icon: { type:String }
        }
    }

    render() {
        const fullpath = new URL(import.meta.url).pathname;
        var ix = fullpath.lastIndexOf('/');
        var path = fullpath.substring(0, ix+1);
        return html`
            <style>
                :host { display:inline-block; width:24px; height:24px; fill:inherit; }
                :host([hidden]) { display:none; }
            </style>
            <svg style="height:100%; width:100%" viewbox="0 0 24 24"><use href="${path}bright.svg#${this.icon}" style="fill-rule:evenodd;clip-rule:evenodd;"></use></svg>
        `;
    }
}
window.customElements.define("bright-icon", BrightIcon);


export class BrightTextArea extends LitElement {
    // this is a form-associated custom component
    // https://web.dev/more-capable-form-controls/ 
    static formAssociated = true;

    static get properties() {
        return {
            value: { type:String, attribute:true }, 
            required: { type:Boolean }, 
            placeholder: { type:String }, 
            label: { type:String }, 
            password: { type:Boolean },
            type: { type:String }, 
            name: { type:String }
        }
    }

    get value() {
        return this._value; 
    }

    set value(value) {
        this._value = (value == "null" || value == "undefined" || value == null || value == undefined) ? "" : value;
        this.internals_.setFormValue(this._value);
        this.requestUpdate();
    }

    constructor() {
        super();
        this._value = "";
        this.internals_ = this.attachInternals();
    }

    static styles = [sharedStyle, css`
        :host { display:block; box-sizing:border-box; }
        :host([hidden]) { display:none; }
        wrap { width:100%; padding:0px; }
        textarea { width:100%; margin:0px 0px -4px 0px; max-width:100%; resize:vertical;  }
    `];

    render() { 
        return html`
            <div part="wrap" id="wrap">
                ${this.label ? html`<label part="label" for="${this.name}">${this.label}</label>` : html``}
                <textarea part="input" type="${this.type}" name="${this.name}" @input="${this.valueInput}" placeholder="${this.placeholder ? this.placeholder : ""}">${this._value}</textarea>
            </div>
            `; 
    }

    firstUpdated() {
        this.input = this.shadowRoot.querySelector("textarea");
        this.dispatchEvent(new CustomEvent("bright-validatable", {
            bubbles: true, 
            composed: true
        }));
    }

    valueInput() {
        this._value = this.input.value;
        this.internals_.setFormValue(this._value);
        this.dispatchEvent(new Event("change", { composed:true, bubbles:true }));
    }

    validate() {
        var valid = true; 
        if(this.required && this._value == "") valid = false; 
        this.input.setCustomValidity(valid ? "" : "required field");
        this.input.valid = valid; 
        return valid; 
    }
}

window.customElements.define("bright-textarea", BrightTextArea);

export class BrightInput extends LitElement {
    // this is a form-associated custom component
    // https://web.dev/more-capable-form-controls/ 
    static formAssociated = true;

    static get properties() {
        return {
            value: { type:String, attribute:true }, 
            required: { type:Boolean }, 
            placeholder: { type:String }, 
            label: { type:String }, 
            password: { type:Boolean },
            type: { type:String }, 
            name: { type:String }
        }
    }

    get value() {
        return this._value; 
    }

    set value(value) {
        this._value = (value == "null" || value == "undefined" || value == null || value == undefined) ? "" : value;
        this.internals_.setFormValue(this._value);
        this.requestUpdate();
    }

    constructor() {
        super();
        this._value = "";
        this.internals_ = this.attachInternals();
    }

    static styles = [sharedStyle, css`
        :host { display:block; box-sizing:border-box; }
        :host([hidden]) { display:none; }
        wrap { width:100%; }
    `];

    render() { 
        return html`
            <div part="wrap" id="wrap">
                ${this.label ? html`<label part="label" for="${this.name}">${this.label}</label>` : html``}
                <input part="input" type="${this.type}" name="${this.name}" @input="${this.valueInput}" placeholder="${this.placeholder ? this.placeholder : ""}" .value="${this._value}">
            </div>
        `; 
    }

    firstUpdated() {
        this.input = this.shadowRoot.querySelector("input");
        this.dispatchEvent(new CustomEvent("bright-validatable", {
            bubbles: true, 
            composed: true
        }));
    }

    valueInput() {
        this._value = this.input.value;
        this.internals_.setFormValue(this._value);
        this.dispatchEvent(new Event("change", { composed:true, bubbles:true }));
    }

    validate() {
        var valid = true; 
        if(this.required && this._value == "") valid = false; 
        this.input.setCustomValidity(valid ? "" : "required field");
        this.input.valid = valid; 
        return valid; 
    }
}

window.customElements.define("bright-input", BrightInput);

export default class BrightToast extends LitElement {

    render() {
        return html`
            <style>
                #wrap { position:fixed; opacity:0; transition: opacity 0.5s; top:0; right:0; left:0; bottom:0; height:100%; width:100%; display:none; align-items:center; justify-content:center; z-index:10000; }
                #messageBox { background-color:var(--body-inverse); max-width:420px; border-radius:3px; color:var(--body-background); padding:32px; }
            </style>
            <div id="wrap">
                <div id="messageBox">${this.message}</div>
            </div>
        `;
    }

    static show(message) {
        // export resolve and reject to the event
        return new Promise((resolve, reject) => {
            window.dispatchEvent(new CustomEvent("bright-toast", {
                composed:true, 
                bubbles:true, 
                detail: { 
                    message: message, 
                    resolve: resolve, 
                    reject: reject }
            }));
        });
    }

    constructor() {
        super();
        let self = this; 
        this.message = "Test toast";
        this.onToast = function(e) {
            // unpack resolve and reject and show dialog
            self.resolve = e.detail.resolve; 
            self.message = e.detail.message; 
            var wrap = self.shadowRoot.getElementById("wrap");
            wrap.style.display = "flex";
            wrap.style.opacity = "1.0";
            self.requestUpdate();
            setTimeout(() => {
                wrap.style.opacity = "0.0";
                setTimeout(() => {
                    wrap.style.display = "none";
                    self.requestUpdate();
                    self.resolve();
                }, 500);
            }, 1500);
        }
    }

    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('bright-toast', this.onToast);
    }

    disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener('bright-toast', this.onToast);
    }
}
window.customElements.define("bright-toast", BrightToast);

export class BrightField extends LitElement {

    static get properties() {
        return {
            label: { type: String }, 
            icon: { type: String }, 
            notext: { type:String }, 
            wrap: { type:Boolean }
        };
    }

    render() {
        const ellipsizeStyle = { minWidth:"0px", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" };
        const normalStyle = { };
        return html`
            <style>
                :host { display:block; }
                :host([hidden]) { display:none; }
                #content { display:block; }
                .ellipsis { min-width:0px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
                label { display:block; text-transform:var(--label-text-transform); font:var(--label-font); }
            </style>
            ${(this.label == undefined) ? html`` : html`<label for="content">${this.label}</div>`}
            <div id="content" class="${this.wrap ? "wrapped" : "ellipsis"}"><slot></slot>${this.notext}</div>
        `;
    }

    firstUpdated() {
        let self = this;
        // the slot change event fires when new child nodes are added to the slot
        this.shadowRoot.addEventListener("slotchange", e => {
            self.nodes = e.target.assignedNodes();
            self.noText = self.hasText(this.nodes) ? "" : "None";
        });
        // the mutation observer fires when text inside child nodes is updated
        const config = { characterData: true, subtree: true };
        const callback = function(mutationsList, observer) {
            self.noText = self.hasText(self.nodes) ? "" : "None";
        };
        const observer = new MutationObserver(callback);
        observer.observe(this, config);
    }

    hasText(nodes) {
        var pat = /\w/;
        for(var i = 0; i < nodes.length; i++) {
            if(pat.test(nodes[i].textContent)) return true;
            if(nodes[i].childNodes && this.hasText(nodes[i].childNodes)) return true; 
        };
        return false; 
    }
}
window.customElements.define("bright-field", BrightField);

export class BrightTabs extends LitElement {

    static get properties() {
        return {
            selectedIndex: { type:Number }
        }
    }

    constructor() {
        super(); 
        this.selectedIndex = 0;
    }

    render() {
        return html`
            <style>
                #wrap { display:flex; border-bottom:1px solid var(--body-inverse); font:var(--button-font);   }
                :host([hidden]) { display:none; }
                ::slotted(div) { flex:1 1 80px; color:var(--body-color); display:flex; transition:background .6s;  flex-direction:column; align-items:center; padding:var(--button-padding); text-transform:var(--button-text-transform); cursor:pointer; user-select:none; box-sizing:border-box; }
                ::slotted(div:hover) { background-color:var(--body-inverse); color:var(--body-background); }
                ::slotted(div.unselected) { border-bottom:4px solid transparent; }    
                ::slotted(div.selected) { border-bottom:4px solid var(--body-inverse); }
            </style>
            <div id="wrap">
                <slot></slot>
            </div>
        `;
    }

    firstUpdated() {
        var tabs = this.children;
        let self = this;
        for(var i = 0; i < tabs.length; i++) {
            tabs[i].addEventListener("click", e => {
                for (var j = 0; j < tabs.length; j++) {
                    if(e.currentTarget == tabs[j]) {
                        if(this.selectedIndex != j) {
                            this.selectedIndex = j;
                            this.dispatchEvent(new Event("change"));
                        }
                        tabs[j].className = "selected";
                    } else {
                        tabs[j].className = "unselected";
                    }
                }
            });
            tabs[i].className =(i == this.selectedIndex) ? "selected" : "unselected";
        }
    }
}

window.customElements.define("bright-tabs", BrightTabs);

export class BrightCard extends LitElement {

    static get properties() {
        return {
            backgroundSrc: { type:String, attribute:"background-src" }, 
            justifyFooter: { type:String, attribute:"justify-footer" }, 
            justifyHeader: { type:String, attribute:"justify-header" }, 
            loading: { type:Boolean }
        };
    }

    constructor() {
        super();
        this.justifyFooter = "flex-end";
        this.justifyHeader = "center";
        this.loading = false;
    }

    render() {
        return html`
            <style>
                :host { display:flex; position:relative; background:var(--body-background); box-sizing:border-box; gap:32px; padding:32px; align-items:stretch; flex-direction:column; box-shadow:var(--shadow); background-image:url(${this.backgroundSrc}); background-position:center; background-size:cover; }
                :host([hidden]) { display:none; }
                #body { overflow-y:auto; flex:1 1 auto; }
                #footer { display:none; position:relative; justify-content:${this.justifyFooter}; align-items:center; flex-wrap:wrap; gap:4px; background-position:center; background-size:cover; }
                #header { display:none; justify-content:${this.justifyHeader}; align-items:center; flex-wrap:wrap; gap:4px; background-position:center; background-size:cover; }
                ::-webkit-scrollbar { background:var(--body-background); width:6px; } 
                ::-webkit-scrollbar-thumb { color:red; background:var(--body-inverse); border-radius:3px; }
                ::slotted(*) { margin-top:0px !important; margin-bottom:0px !important; }
                bright-progress { position:absolute; bottom:0px; left:0px; width:100%;  }
                #blocker { display:${this.loading?"block":"none"}; position:absolute; top:0px; left:0px; right:0px; bottom:0px; background:var(--body-background); opacity:0.5; }
            </style>
            <div part="header" id="header">
                <slot name="header" @slotchange="${this.slotChange}"></slot>
            </div>
            <div part="body" id="body">
                <slot></slot>
            </div>
            <div part="footer" id="footer">
                <div id="blocker"></div>
                <slot name="footer" @slotchange="${this.slotChange}"></slot>
                
            </div>
            <bright-progress ?visible="${this.loading}"></bright-progress>
        `; 
    }

    slotChange(e) {
        const childNodes = e.target.assignedNodes({flatten: true});
        if(childNodes.length > 0) e.target.parentElement.style.display = "flex";
    }
}
window.customElements.define("bright-card", BrightCard);


export class BrightDialog extends LitElement {

    static styles = [sharedStyle, css`
        :host { display:none; box-sizing:border-box; justify-content:center; align-items:center; height:100%; width:100%; position:fixed; top:0; left:0; z-index:10000; background-color:rgba(0,0,0,0.7); }
        bright-card { max-width:500px; max-height:90%; }
        @media (max-width: 460px) {
            :host { max-height:100%; max-width:100%; }
            bright-card { width:100%; height:100%; min-height:100%; min-width:100%;  max-height:100%; max-width:100%;  }
        }
    `];

    static properties = {
        loading: { type:Boolean }
    };

    constructor() {
        super(); 
        this.loading = false;
    }

    render() {
        return html`
            <bright-card part="card" ?loading="${this.loading}">
                <slot name="header" slot="header"></slot>
                <slot></slot>
                <slot name="footer" slot="footer"></slot>
            </bright-card>
        `; 
    }

    show() {
        this.style.display = "flex";
    }

    hide() {
        this.style.display = "none";
    }
}
window.customElements.define("bright-dialog", BrightDialog)

export class BrightSection extends LitElement {

    static get properties() {
        return {
            background: { type: String },
            itemwidth: { type: String, attribute: "item-width" },
            itemheight: { type: String, attribute: "item-height" }
        };
    }

    render() {
        return html`
            <style>
                :host { display:block; width:100%; box-sizing:border-box; background-image:url(${this.background}); background-position:center; background-size:cover;  }
                :host([hidden]) { display:none; }
                div { margin:auto; height:100%; display:flex; flex-wrap:wrap; max-width:var(--content-width); align-items:stretch; align-content:center; justify-content:center; gap:32px; }
                ::slotted(*) { flex:1 1 auto; max-width:${this.itemwidth}; height:${this.itemheight} }

                @media (max-width: 460px) {
                    div { padding:16px !important; gap:16px !important;  }
                    ::slotted(*) { flex: 1 1 auto; max-width:100%; }
                }
            </style>
            <div part="content">
                <slot></slot>
            </div>
        `; 
    }
}
window.customElements.define("bright-section", BrightSection);

export class BrightLightbox extends LitElement {
    static get properties() {
        return {
            src: { type:String, attribute:"src" }, 
            caption: { type:String, attribute:"caption"}, 
            paging: { type:Boolean, attribute:"paging" }, 
            current: { type:Object } // current img or figure child of the lightbox
        };
    }

    constructor() {
        super();
        this.paging = true;
    }

    render() {
        return html`
            <style>
                :host { display:none; width:100%; height:100%; top:0px; left:0px; z-index:100; box-sizing:border-box; position:fixed; flex-direction:column; align-items:center; justify-content:center; background-color:black; user-select:none; }
                :host([hidden]) { display:none; }
                img { max-height:90%; max-width:100%; box-sizing:border-box; user-select:none; }
                div { color:white; padding:16px; }
                bright-icon { height:32px; width:32px; position:absolute; fill:white; filter: drop-shadow(1px 1px 3px #000000); }
                #closeicon { top:16px; right:16px; z-index:150; }
                #nexticon { right:16px; top:50%; z-index:150; translate:0px -50%; display:${ this.paging && this.hasNext ? "block" : "none" }; }
                #previcon { left:16px; top:50%; z-index:150; translate:0px -50%; display:${ this.paging && this.hasPrev ? "block" : "none" }; }
            </style>
            <bright-icon id="closeicon" icon="clear" @click="${this.closeClick}"></bright-icon>
            <bright-icon id="nexticon" icon="arrow-forward" @click="${this.nextClick}"></bright-icon>
            <bright-icon id="previcon" icon="arrow-back" @click="${this.prevClick}"></bright-icon>
            <img src="${this.src}"/>
            <div>${this.caption}</div>
        `;
    }

    firstUpdated() {
        this.img = this.shadowRoot.querySelector("img");
    }

    show(ele) {
        this.load(ele);
        this.style.display = "flex"
        this.animate([ 
            { opacity:0 },
            { opacity:1 } 
        ], { duration:300, easing:'ease-out', fill: 'both' } );
    }

    load(ele) {
        this.caption = ele.getAttribute("title"); 
        this.current = ele; 
        this.src = ele.src; 
        this.hasNext = this.current.nextElementSibling != null;
        this.hasPrev = this.current.previousElementSibling != null;
    }

    closeClick() {
        this.animate([ 
            { opacity:1 },
            { opacity:0 } 
        ], { duration:300, easing:'ease-out', fill: 'both' } ).onfinish = () => {
            this.style.display = "none";
        };
    }

    nextClick() {
        this.img.animate([ { transform:'translateX(-50%)', opacity:0 }], { duration:300, easing:'ease-out', fill: 'both' } ).onfinish = () => {
            this.load(this.current.nextElementSibling);
            this.img.animate([ 
                { transform:'translateX(50%)', opacity:0 },
                { transform:'translateX(0)', opacity:1 } 
            ], { duration:300, easing:'ease-in', fill: 'both' } );
        };
    }

    prevClick() {
        this.img.animate([ { transform:'translateX(50%)', opacity:0 }], { duration:300, easing:'ease-out', fill: 'both' } ).onfinish = () => {
            this.load(this.current.previousElementSibling);
            this.img.animate([ 
                { transform:'translateX(-50%)', opacity:0 },
                { transform:'translateX(0)', opacity:1 } 
            ], { duration:300, easing:'ease-in', fill: 'both' } );
        };
    }

}
window.customElements.define("bright-lightbox", BrightLightbox);

export class BrightGalleryGrid extends LitElement {
    resizer = new ResizeController(this);

    static get properties() {
        return { 
            template: { type:String, attribute:"template" }
        };
    }

    constructor() {
        super();
    }

    render() {
        return html`
        <style>
            :host { width:100%; display:grid; box-sizing:border-box;grid-template-rows:repeat(min-content); grid-template-columns:repeat(auto-fill, minmax(150px, 1fr)); align-items:stretch; gap:8px; }
            :host([hidden]) { display:none; }
            ::slotted(*) { width:100%; box-sizing:border-box; object-fit:contain; }
        </style>
        <slot @click="${this.itemClick}"></slot>
        <bright-lightbox></bright-lightbox>
        `; 
    }

    itemClick(e) {
        this.renderRoot.querySelector("bright-lightbox").show(e.srcElement);
    }
}
window.customElements.define("bright-gallery-grid", BrightGalleryGrid);

export class BrightGalleryScroller extends LitElement {
    resizer = new ResizeController(this);
    
    static get properties() {
        return {
            itemwidth: { type: String, attribute:"item-width" }, 
            gap: { type:String, attribute:"gap" }, 
            _index: { type:Number }
        };
    }

    constructor() {
        super();
        this.itemwidth = "30%", 
        this.gap = "5%"
        this._index = 0; 
    }

    render() {
        return html`
        <style>
            :host { display:block; width:100%; box-sizing:border-box; position:relative;  }
            :host([hidden]) { display:none; }
            #main { max-width:var(--content-width); display:flex; justify-content:flex-start; gap:${this.gap}; overflow-x:scroll; }
            ::slotted(img) { max-width:${this.itemwidth}; }
            ::-webkit-scrollbar { display: none; }
            #main { -ms-overflow-style: none; scrollbar-width: none; }
            #prev, #next { position:absolute; top:50%;transform: translate(0%, -50%); height:32px; width:32px; fill:white; filter: drop-shadow(3px 3px 2px #000000); }
            #prev { left:32px; display:none; }
            #next { right:32px; }
        </style>
        <bright-icon id="prev" @click="${this.prev}" icon="arrow-back"></bright-icon>
        <bright-icon id="next" @click="${this.next}" icon="arrow-forward"></bright-icon>
        <div id="main">
            <slot @click="${this.itemClick}"></slot>
        </div>
        <bright-lightbox></bright-lightbox>
        `; 
    }

    firstUpdated() {
        const slot = this.shadowRoot.querySelector('slot');
        this.imgs = slot.assignedElements({flatten: true});
        this.prevIcon = this.shadowRoot.querySelector("#prev");
        this.nextIcon = this.shadowRoot.querySelector("#next");
        this.initScroller(); 
    }

    async initScroller() {
        await this.updateComplete; 
        var gallery = this.offsetWidth;
        var img = this.imgs[0].width;
        var main = this.shadowRoot.querySelector("#main");
        if(img > gallery) {
            var towidth = (img-gallery);
            main.scrollTo(towidth, 0);
        }
    }

    next() {
        if(this._index < this.imgs.length-1) this._index++;
        this.scroll();
    }

    prev() {
        if(this._index > 0) this._index--;
        this.scroll();
    }

    scroll() {
        this.nextIcon.style.display = (this._index == this.imgs.length-1) ? "none" : "block";
        this.prevIcon.style.display = (this._index == 0) ? "none" : "block";
        this.imgs[this._index].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
    }

    itemClick(e) {
        this.renderRoot.querySelector("bright-lightbox").show(e.srcElement);
    }
}
window.customElements.define("bright-gallery-scroller", BrightGalleryScroller);


export class BrightEditor extends LitElement {
    // this is a form-associated custom component
    // https://web.dev/more-capable-form-controls/ 
    static formAssociated = true;

    static properties = {
        label: { type:String },
        value: { type: String },
        name: { type: String }
    };

    constructor() {
        super();
        this.value = '';
        this.editorRef = null;
        this.internals_ = this.attachInternals();
        this._editMode = false; 
    }

    static styles = css`
        :host { display:block; min-width:100%; }
        img { max-width: 100%; resize;both; height:auto; }
        #toolbar { display:flex; gap:2px; flex-wrap:wrap; justify-content:stretch; }
        #toolbar * { flex:1 1 auto; background:var(--label-background); fill:var(--label-inverse); padding:4px;  }
        #htmltext { flex:1 1 auto; width:100%; min-height:150px; display:block;  box-sizing:border-box; outline:none; border:var(--input-border);padding:var(--input-padding);  }
        #editable { flex:1 1 auto; min-height:150px; box-sizing:border-box; cursor:text; background:var(--input-background);padding:var(--input-padding); border:var(--input-border); outline:none; color:var(--input-inverse); border-radius:var(--input-radius); }
        label { margin-bottom:2px; display:block; font:var(--label-font); background:var(--label-background); color:var(--label-inverse);padding:var(--label-padding); text-transform:var(--label-text-transform); }
    `;

    render() {
        return html`
        <div id="wrap">
            ${this.label ? html`<label part="label" for="${this.name}">${this.label}</label>` : html``}
            <div id="toolbar" part="toolbar">
                <bright-icon icon="format-bold" @mousedown="${this.onBold}"></bright-icon>
                <bright-icon icon="format-italic" @mousedown="${this.onItalic}"></bright-icon>
                <bright-icon icon="format-underlined" @mousedown="${this.onUnderline}"></bright-icon>
                <bright-icon icon="insert-link" @mousedown="${this.onLink}"></bright-icon>
                <bright-icon icon="title" @mousedown="${this.onHeader}"></bright-icon>
                <bright-icon icon="insert-photo" @mousedown="${this.onImage}"></bright-icon>
                <bright-icon icon="format-align-left" @mousedown="${this.onLeft}"></bright-icon>
                <bright-icon icon="format-align-center" @mousedown="${this.onCenter}"></bright-icon>
                <bright-icon icon="format-align-right" @mousedown="${this.onRight}"></bright-icon>
                <bright-icon icon="mode-edit" @mousedown="${this.onMode}"></bright-icon>
            </div>
            <div id="editable" class="editable" part="editable" contenteditable="true" @input="${this.onInput}"></div>
            <textarea id="htmltext" name="${this.name}" @input="${this.onTextInput}" style="display:none">${this.value}</textarea>
        </div>
        `;
    }

    firstUpdated() {
        this.editorRef = this.renderRoot.querySelector("#editable");
        this.editorRef.innerHTML = this.value;
        this.internals_.setFormValue(this.value);
    }

    onMode() {
        this._editMode = !this._editMode; 
        this.editorRef.style.display = this._editMode ? "none" : "block";
        this.renderRoot.querySelector("#htmltext").style.display = this._editMode ? "block" : "none";
    }

    onInput() {
        if (this.editorRef) {
        this.value = this.editorRef.innerHTML;
        this.internals_.setFormValue(this.value);
        }
    }

    onTextInput() {
        this.value = this.renderRoot.querySelector("#htmltext").value;
        this.internals_.setFormValue(this.value);
        this.editorRef.innerHTML = this.value; 
    }

    onBold() {
        document.execCommand('bold', false, null);
    }
    onItalic() {
        document.execCommand('italic', false, null);
    }
    onUnderline() {
        document.execCommand('underline', false, null);
    }
    onLeft() {
        document.execCommand('justifyLeft', false, null);
    }
    onCenter() {
        document.execCommand('justifyCenter', false, null);
    }
    onRight() {
        document.execCommand('justifyRight', false, null);
    }

    onLink() {
        var input = prompt("Url to Link");
        document.execCommand("CreateLink", false, input);
    }

    onHeader() {
        var selection = this.renderRoot.getSelection();
        var range = selection.getRangeAt(0);
        var h1 = document.createElement("h1");
        range.surroundContents(h1);
        this.value = this.editorRef.innerHTML;
        this.internals_.setFormValue(this.value);
    }

    onImage() {
        var input = prompt("Url to Image");
        document.execCommand("InsertImage", false, input);
    }
}

customElements.define('bright-editor', BrightEditor);
  

export class BrightLoader extends LitElement {

    static get properties() {
        return {
            visible: { type: Boolean }
        };
    }

    constructor() {
        super();
        this.visible = true;
    }

    render() {
        return html`
        <style>
            :host { height:100%; width:100%; visibility:${this.visible ? "visible" : "hidden"} }
            .wrap { height:100%; width:100%; display:flex; align-items:center; justify-content:center;  }
            svg { fill:var(--tertiary); }
        </style>
        <div class="wrap" style="visibility:${this.visible ? 'visible' : 'hidden'}">
            <svg id="loader" width="48" height="48" viewBox="24 24 50 50">
                <path d="M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50">
                <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="1s" from="0 50 50"to="360 50 50" repeatCount="indefinite"/>
                </path>
            </svg>
        </div>
    `;
    }
}
window.customElements.define("bright-loader", BrightLoader);

export class BrightProgress extends LitElement {

    static get properties() {
        return {
            visible: { type: Boolean, reflect:true }
        };
    }

    constructor() {
        super();
        this.visible = false;
    }

    render() {
        return html`
            <style>
                :host { display:block; visibility:${this.visible ? 'visible' : 'hidden' } }
                :host([hidden]) { display:none; }
                .slider { position:relative; width:100%; height:5px; overflow-x: hidden; }
                .line { position:absolute; opacity: 0.4; background:var(--body-inverse); width:150%; height:5px; }
                .subline { position:absolute; background:var(--body-inverse); height:5px;  }
                .inc { animation: increase 2s infinite; }
                .dec { animation: decrease 2s 0.5s infinite; }
                @keyframes increase {
                    from { left: -5%; width: 5%; }
                    to { left: 130%; width: 100%;}
                }
                @keyframes decrease {
                    from { left: -80%; width: 80%; }
                    to { left: 110%; width: 10%;}
                }
            </style>
            <div>
                <div class="slider">
                    <div class="line"></div>
                    <div class="subline inc"></div>
                    <div class="subline dec"></div>
                </div>
            </div>
        `;
    }
}

window.customElements.define("bright-progress", BrightProgress);

export class BrightSelect extends LitElement {

    static get properties() {
        return {
            value: { type:String }, 
            required: { type:Boolean }, 
            placeholder: { type:String }, 
            text: { type:String },
            label: { type:String }
        }
    }

    constructor() {
        super(); 
        this.placeholder = "";
        this.value = "";
    }

    static styles = [sharedStyle, css`
        :host { display:block; cursor:pointer; box-sizing:border-box; }
        :host([hidden]) { display:none; }
        #wrap { position:relative; box-sizing:border-box; width:100%; }
        input { cursor:pointer; }
        #dropdown { z-index:10; outline:none; color:var(--input-inverse); background-color:var(--input-background); display:none; position:absolute; top:34px; left:0px; right:0px; border:var(--input-border); user-select:none; }
        #dropdown ::slotted(*) { padding:16px; }
        #dropdown ::slotted(*:hover) { background-color:var(--input-inverse); color:var(--input-background); }
        #icon { position:absolute; height:24px; width:20px; right:4px; top:6px; fill:gray; pointer-events:none; }
    `];

    render() {
        return html`
        ${ this.label ? html`<label class="label">${this.label}</label>` : html`` }
        <div id="wrap">
            <input type="text" id="input" tabindex="-1" @mousedown="${this.inputMouseDown}" placeholder="${this.placeholder}"/>
            <!-- tabindex necessary for div to gain focus -->
            <div id="dropdown" @blur="${this.slotBlur}" tabindex="-1"> 
                <slot @mousedown="${this.slotMouseDown}"></slot>
            </div>
            <svg viewbox="0 0 24 24" id="icon">
                <g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
            </svg>
        </div>
        `;
    }

    firstUpdated() {
        this.dropdown = this.shadowRoot.getElementById("dropdown");
        this.input = this.shadowRoot.getElementById("input");
        this.input.value = this.value; 
        this.dispatchEvent(new CustomEvent("bright-validatable", { bubbles: true, composed: true }));
    }

    inputMouseDown(e) {
        e.preventDefault();
        this.dropdown.style.display = (this.dropdown.style.display == "block") ? "none" : "block";
        this.dropdown.focus();
    }

    slotBlur(e) {
        this.dropdown.style.display = "none";
    }

    slotMouseDown(e) {
        this.dropdown.style.display = "none";
        this.value = e.target.getAttribute("value");
        if(this.value == null) this._value = e.target.innerText;
        this.input.value = e.target.innerText; 
        this.text = e.target.innerText;
    }

    validate() {
        var valid = true; 
        if(this.required && (this._value == "" || this._value == undefined)) valid = false; 
        this.input.setCustomValidity(valid ? "" : "required field");
        this.input.valid = valid; 
        return valid; 
    }
}
window.customElements.define("bright-select", BrightSelect);

export class BrightDatePick extends LitElement {

    static properties = {
        focusDay: { type:Date }, 
        label: { type:String },
        mode: {  type:Number, state:true }
    };

    static styles = [ sharedStyle, css`
        :host { }
        .buttons { cursor:pointer; margin:2px 0px; background:var(--button-background); fill:var(--button-inverse); padding:8px; flex: 1 1 200px; text-align:center; }
        .up2 { display:flex; gap:2px; }
        .grid { display:grid; height:300px; gap:2px; align-items:stretch; justify-items:stretch; }
        .grid div { display:flex; align-items:center; justify-content:center; }
        .grid .th { color:var(--label-color); background:var(--label-background); user-select:none; }
        .grid .td { cursor:pointer; }
        .grid .td:hover { background:var(--button-background);  }
    `];

    constructor() {
        super();
        this.focusDay = new Date; 
    }

    render() {
        return html`
            ${this.label ? html`<label part="label" for="${this.name}">${this.label}</label>` : html``}
            <div class="up2">
                <div class="buttons" @click="${() => {this.mode = 1}}">${this.focusDay.toLocaleString('default', { month: 'long' })}</div>
                <div class="buttons" @click="${() => {this.mode = 2}}">${this.focusDay.getFullYear()}</div>
            </div>
            ${this.getTemplate()}
            <div class="up2">
                <div class="buttons" @click="${this.backClick}"><bright-icon icon="arrow-back"></bright-icon></div>
                <div class="buttons" @click="${this.fwrdClick}"><bright-icon icon="arrow-forward"></bright-icon></div>
            </div>

        `;
    }

    getTemplate() {
        switch(this.mode) {
            case 2: 
                return this.yearGrid(this.focusDay);
            case 1: 
                return this.monthGrid();
            default: 
                return this.dayGrid(this.focusDay);
        }
    }

    yearGrid(value) {
        var year = value.getFullYear() - 12;
        var cells = []; 
        for(var y = 0; y < 5; y++) {
            for(var x = 0; x < 5; x++) {
                cells.push(html`<div class="td">${year}</div>`);
                year++;
            }
        }
        return html`
            <div class="grid" @click="${this.yearClick}" style="grid-template-columns:1fr 1fr 1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr 1fr 1fr;">
                ${cells}
            </div>
        `;
    }

    monthGrid() {
        return html`
            <div class="grid" @click="${this.monthClick}" style="grid-template-columns:1fr 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;">
            <div value="0" class="td">Jan</div><div value="1" class="td">Feb</div><div value="2" class="td">Mar</div><div value="3" class="td">Apr</div>
            <div value="4" class="td">May</div><div value="5" class="td">Jun</div><div value="6" class="td">Jul</div><div value="7" class="td">Aug</div>
            <div value="8" class="td">Sep</div><div value="9" class="td">Oct</div><div value="10" class="td">Nov</div><div value="11 class="td"">Dec</div>
            </div>
        `;
    }

    dayGrid(value) {
        var start = DateUtil.firstOfWeek(DateUtil.firstOfMonth(value)); 
        let date = start; 

        let daycells =[];
        for (var x = 0; x < 6; x++) {     
            for(var y = 0; y < 7; y++) {
                daycells.push(html`<div class="td" value="${date.toISOString()}">${date.getDate()}</div>`);
                date.setDate(date.getDate() + 1);
            }
        }
        return html`
            <div @click="${this.dayClick}" style="grid-template-columns:1fr 1fr 1fr 1fr 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr 1fr;" class="grid">
                <div class="th">Sun</div><div class="th">Mon</div><div class="th">Tue</div><div class="th">Wed</div><div class="th">Thu</div><div class="th">Fri</div><div class="th">Sat</div>
                ${daycells}
            </div>
        `;
    }

    backClick() {
        switch(this.mode) {
            case 2: 
                this.focusDay.setFullYear(this.focusDay.getFullYear() - 25);
                break; 
            case 1:
                this.focusDay.setFullYear(this.focusDay.getFullYear() - 1);
                break; 
            default:
                this.focusDay.setMonth(this.focusDay.getMonth() - 1);
                break; 
        }
        this.requestUpdate();
    }

    fwrdClick() {
        switch(this.mode) {
            case 2: 
                this.focusDay.setFullYear(this.focusDay.getFullYear() + 25);
                break; 
            case 1:
                this.focusDay.setFullYear(this.focusDay.getFullYear() + 1);
                break; 
            default:
                this.focusDay.setMonth(this.focusDay.getMonth() + 1);
                break; 
        }
        this.requestUpdate();
    }

    yearClick(e) {
        let yr = Number(e.target.innerText);
        this.focusDay.setFullYear(yr);
        this.mode = 0;
    }

    monthClick(e) {
        let mo = Number(e.target.getAttribute("value"));
        this.focusDay.setMonth(mo);
        this.mode = 0; 
    }

    dayClick(e) {
        let date = new Date(e.target.getAttribute("value"));
        this.dispatchEvent(new CustomEvent("datepicked", { bubbles:true, composed:true, detail:date }));
    }
}
window.customElements.define("bright-datepick", BrightDatePick);

export class BrightDateInput extends LitElement {

    static properties = {
        label: { type:String }
    } 

    static styles = css`
        :host { display:block; }
        bright-dialog::part(card) { width:400px; }
    `;

    render() {
        return html`
            <bright-input id="input" @click="${this.inputClick}" label="${this.label}"></bright-input>
            <bright-dialog id="dialog">
                <h2 slot="header">Select A Date</h2>
                <bright-datepick @datepicked="${this.datePicked}"></bright-datepick>
            </bright-dialog>
        `;
    }

    datePicked(e) {
        var date = DateUtil.formatShort(e.detail);
        this.shadowRoot.querySelector("#input").value = date;
        this.shadowRoot.querySelector("#dialog").hide();
    }

    inputClick(e) {
        e.preventDefault();
        this.shadowRoot.querySelector("#dialog").show();
    }
}
window.customElements.define("bright-dateinput", BrightDateInput)

export class BrightVideo extends LitElement {
    static properties = {
        src: { type:String }, 
        poster: { type:String }
    }

    static styles = css`
        video { max-width:100%; }
    `;

    render() {
        return html`
            <video @click="${this.click}" src="${this.src}" controls controlslist="nodownload" preload="none" poster="${this.poster}"></video>
        `;
    }

    click() {
        this.shadowRoot.querySelector("video").play();
    }
}
window.customElements.define("bright-video", BrightVideo);

export class BrightIconLine extends LitElement {

    static properties = {
        icon: { type:String }, 
        href: { type:String }
    };

    static styles = css`
        :host { display:flex; height:56px; align-items:center; padding:0px 16px; gap:16px; background:var(--body-background); color:var(--body-inverse); cursor:pointer; user-select:none; }
        :host(:hover) { background:var(--button-background); color:var(--button-color); }
    `;

    constructor() {
        super();
        this.addEventListener('click', () => { if(this.href) window.location.href = this.href; });
    }

    render() {
        return html`
            <bright-icon icon="${this.icon}"></bright-icon>
            <slot></slot>
        `;
    }
}
window.customElements.define("bright-iconline", BrightIconLine);

export class AppBar extends LitElement {

    render() {
        return html`
            <style>
                :host { display:flex; box-sizing:border-box; background:var(--body-inverse); color:var(--body-background); fill:var(--body-background); height:56px; align-items:center; padding:0px 16px; gap:16px; ; }
                :host([hidden]) { display:none; }
            </style>
                <bright-icon icon="menu" @click="${this.menuClick}"></bright-icon>
                <slot></slot>
            </div>
        `;
    }

    menuClick() {
        this.dispatchEvent(new CustomEvent("appbar-toggle", { bubbles:true, composed:true }));
    }
}
window.customElements.define("app-bar", AppBar);

export class AppLayout extends LitElement {

    static properties = {
        collapsed: { type:Boolean }
    };

    static styles = css`
        #appbar { position:fixed; width:300px; left:0px; top:0px; height:56px; }
        #appnav { position:fixed; width:300px; left:0px; top:56px; bottom:0px; overflow-y:hidden; background:var(--body-background); transition:bottom 0.5s; }
        #body { position:fixed; left:300px; top:0px; right:0px; bottom:0px; }
        @media only screen and (max-width: 600px) 
        {
            #appbar { width:100%; }
            #appnav { width:100%; }
            #appnav.expanded { bottom:0px; }
            #appnav.collapsed { bottom:100%; }
            #body { width:100%; left:0px; top:56px;  }
        }
    `;

    constructor() {
        super(); 
        this.addEventListener('appbar-toggle', () => { this.collapsed = !this.collapsed });
        window.addEventListener('hashchange', () => { this.collapsed = true; });
        this.collapsed = true; 
    }

    render() {
        return html`
            <div id="appbar"><slot name="app-bar"></slot></div>
            <div id="body"><slot></slot></div>
            <div id="appnav" class="${this.collapsed?'collapsed':'expanded'}"><slot name="app-nav"></slot></div>
        `;
    }

}
window.customElements.define("app-layout", AppLayout);

export class AppRouter extends LitElement {

    static properties = {
        children: { type:Array }
    }

    constructor() {
        super();
        this.onHashChange = this.onHashChange.bind(this);
        window.addEventListener('hashchange', this.onHashChange);
    }

    render() {
        return html`
            <slot></slot>
        `;
    }

    onHashChange() {
        this.children.forEach(n =>{
            if(window.location.hash.startsWith(n.getAttribute("route"))) {
                n.style.display = "block";
                // call child.onShow if present
                if(n.onShow) n.onShow(window.location.hash);
            } else {
                if(n.style.display == "block") {
                    n.style.display = "none";
                    // call child.onHide if present
                    if(n.onHide) n.onHide(window.location.hash);
                }
            }
        });
    }

    firstUpdated() {
        this.children = this.shadowRoot.querySelector("slot").assignedElements({ flatten: true });
        this.children.forEach(n => { n.style.display = "none" });
        this.children[0].style.display = "block";
        this.onHashChange();
    }
}
window.customElements.define("app-router", AppRouter);






























// BELOW HERE IS NOT VALIDATED TO WORK UNDER MONARCH CSS/JS
//*************************************************************************************************** */


export class BrightForm extends LitElement {

    static get properties() {
        return { 
            errors: { type:String }
        };
    }

    render() { 
        return html`
            <style>
                :host { display:block; }
                :host:hidden { display:none; }
            </style>        
            <slot></slot>
        `; 
    }

    connectedCallback() {
        super.connectedCallback();
        this.validatables = [];
        this.addEventListener("bright-validatable", e => {
            this.validatables.push(e.composedPath()[0]);
        });
    }

    validate() {
        var valid = true;
        this.error = null;
        this.validatables.forEach(e => {
            if(!e.validate()) {
                valid = false;
                this.error = e.hasAttribute("error") && this.error == null ? e.getAttribute("error") : this.error;
            }
        });
        return valid; 
    }

    getValues(obj) {
        this.validatables.forEach(e => {
            obj[e.id] = e.value == "" ? null : e.value;
        });
        return obj;
    }
}
window.customElements.define("bright-form", BrightForm);

export class ViewPager extends LitElement {
    render() {
        return html`<slot></slot>`;
    }

    firstUpdated() {
        for(let i = 0; i < this.children.length; i++) {
            this.children[i].hidden = true;
        }
    }

    showPage(value) {
        if(isNaN(value)) {
            for(let i = 0; i < this.children.length; i++) {
                this.children[i].hidden = (this.children[i].id != value);
            }
        } else {
            for(let i = 0; i < this.children.length; i++) {
                this.children[i].hidden = (i != value);
            }
        }
    }
}
window.customElements.define("view-pager", ViewPager);

// ******************************************
// SingleSelector wraps single-selectable items
// ******************************************

export class SingleSelector extends LitElement {
    static get properties() {
        return {
            value: { type: String }
        }
    }

    constructor() {
        super();
    }

    firstUpdated() {
        let nodes = this.children;
        for(let i = 0; i<nodes.length; i++) {
            nodes[i].addEventListener("click", e => {
                this.childClick(e);
            });
        }
    }

    updated() {
        this.drawSelection();
    }

    childClick(e) {
        this.value = e.target.getAttribute("value");
        this.drawSelection();
    }

    drawSelection() {
        let nodes = this.children;
        for(let i = 0; i<nodes.length; i++) {
            nodes[i].className = nodes[i].getAttribute("value") == this.value ? "selected" : "notselected";
        }
    }

    render() {
        return html`
            <style>
                :host { display:block; }
                :host([hidden]) { display:none; }
                ::slotted(.selected) { background-color:red; }
            </style>
            <div><slot></slot></div>
        `;
    }
}
window.customElements.define("single-selector", SingleSelector);

// ******************************************
// MultiSelector wraps multi-selectable items
// ******************************************

export class MultiSelector extends LitElement {
    static get properties() {
        return {
            _selected: { type: Array }
        }
    }

    get selected() {
        return this._selected;
    }

    set selected(value) {
        this._selected = value;
        this._registered.forEach(e => { e.selected = this._selected.includes(e.value)});
        this.dispatchEvent(new CustomEvent("change", { composed:true, bubbles:true, detail:this._selected }));
    }

    constructor() {
        super();
        this._registered = [];
        this._selected = [];
    }

    firstUpdated() {
        this.addEventListener("multi-selectable", this.register);
    }

    register(e) {
        this._registered.push(e.target);
        e.target.addEventListener("change", e => {
            e.stopPropagation();
            this._selected = this._registered.filter(r => r.selected == true).map(r => r.value);
            this.dispatchEvent(new CustomEvent("change", { composed:true, bubbles:true, detail:this._selected }));
        });
        if(!this._selected) return;
        e.target.selected = this._selected.includes(e.target.value);
    }

    clearAll() {
        let values = [];
        this.selected = values; 
        this.dispatchEvent(new CustomEvent("change", { composed:true, bubbles:true, detail:this._selected }));
    }

    selectAll() {
        let values = []
        this._registered.forEach(e => { values.push(e.value); });
        this.selected = values;
        this.dispatchEvent(new CustomEvent("change", { composed:true, bubbles:true, detail:this._selected }));
    }

    selectItem(value) {
        this._selected.push(value);
        this.requestUpdate();
        this.dispatchEvent(new CustomEvent("change", { composed:true, bubbles:true, detail:this._selected }));
    }

    render() {
        return html`
            <style>
                :host { display:block; }
                :host([hidden]) { display:none; }
            </style>
            <div><slot></slot></div>
        `;
    }
}
window.customElements.define("multi-selector", MultiSelector);

export class SelectLine extends LitElement {

    static get properties() {
        return {
            value: { type:String },
            selected: { type:Boolean, reflect:true }
        };
    }

    constructor() {
        super();
        this.selected = false; 
        this.value = null; 
    }

    render() {
        return html`
            <style>
                :host { display:block; cursor:pointer;  }
                :host([selected]) { background-color:var(--line-border); }
                div {  display:flex; align-items:center; }
            </style>
            <div ?selected="${this.selected}"><slot></slot></div>
        `;
    }

    firstUpdated() {
        this.dispatchEvent(new CustomEvent("multi-selectable", { bubbles: true, composed: true }));
        this.addEventListener("click", this.click);
    }

    click() {
        this.selected = !this.selected;
        this.dispatchEvent(new CustomEvent("change", { bubbles:true, composed:true }));
    }
}

window.customElements.define("select-line", SelectLine);

export class CheckLine extends LitElement {

    static get properties() {
        return {
            item: { type: Object }, 
            selected: { type: Boolean }
        };
    }

    set selected(value) {
        const old = this.item.selected;
        this.item.selected = value;
        this.requestUpdate();
    }

    get selected() {
        return this.item ? this.item.selected : false;
    }

    get item() {
        return this._item; 
    }

    set item(value) {
        if(value.selected == undefined) value.selected=false;
        this._item = value;
        this.requestUpdate();
    }

    render() {
        return html`
            <style>
                :host { display: flex; height: 44px; align-items: center; cursor:pointer; }
                :host([hidden]) { display:none; }
                svg { height:1.6em; width: 1.6em; color:grey; padding-top:4px; }
                .content { flex: 1 1 auto; padding-left:8px; }
            </style>
            ${(this.item && this.item.selected) ? 
            html`<div><svg xmlns="http://www.w3.org/2000/svg"><path fill="#303030" d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></svg></div>`
            :
            html`<div><svg xmlns="http://www.w3.org/2000/svg"><path fill="#303030" d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></svg></div>`
            }
            <div class="content"><slot></slot></div>
        `;
    }
    
    isChecked(item) {
        return item.selected;
    }

    firstUpdated() {
        this.addEventListener('click', this.onClick);
        this.dispatchEvent(new CustomEvent("multi-selectable", { bubbles: true, composed: true }));
    }

    onClick() {
        this.item.selected = !this.item.selected;
        this.requestUpdate();
    }
}

window.customElements.define("check-line", CheckLine);



export class BrightMenu extends LitElement {

    render() {
        return html`
            <style>
                :host { position: relative; display:inline-block; fill:var(--body-background); }
                :host([hidden]) { display:none; }
                svg { height: 24px; width:24px; border:none; outline:none; }
                #wrap { overflow:hidden; outline:none; transition:max-height 0.3s; background-color:var(--primary); width:200px; max-height:0px; position:absolute; z-index:1000; color:var(--body-background); right:-16px; top:41px; border-radius:3px; box-shadow: 0px 3px 3px rgba(0,0,0,0.4); }
                ::slotted(div) { vertical-align:middle; padding:16px; user-select:none; cursor:pointer; }
                ::slotted(div:hover) { background-color:var(--body-background); color:var(--primary); fill:var(--primary); }
            </style>
            <svg @click="${this.open}" viewbox="2 2 20 20">
                <g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
            </svg>
            <!-- tabindex required to make focus work -->
            <div id="wrap" tabindex="0" @blur="${this.close}">
                <slot></slot>
            </div>
        `;
    }
    
    close() {
        let self = this;
        setTimeout(() => {
            self.shadowRoot.getElementById("wrap").style.maxHeight = "0px";
        }, 500);
    }

    open() {
        let e = this.shadowRoot.getElementById("wrap");
        e.style.maxHeight = "500px";
        e.focus();
    }
}

window.customElements.define("bright-menu", BrightMenu);

export class MenuItem extends LitElement {

    static get properties() {
        return {
            icon: { type: String }
        };
    }

    constructor() {
        super(); 
        this.icon = '';
    }

    render() {
        return html`
            <style>
                :host { display:block; cursor:pointer; }
                :host([hidden]) { display:none; }
                .row { display:flex; align-items:center; padding:16px; color:var(--body-background); vertical-align:middle; }
                .row:hover { color:var(--primary); background-color:var(--body-background); }
                bright-icon { padding-right:8px; fill:var(--body-background); }
                .row:hover bright-icon { fill:var(--primary); }
            </style>
            <div class="row"><bright-icon ?hidden="${this.icon == ''}" fill="red" icon="${this.icon}"></bright-icon><div class="text"><slot></slot></div></div>
        `;
    }
}

window.customElements.define("menu-item", MenuItem);







export class BrightPager extends LitElement {
    render() {
        return html`
            <style>
                :host { display:block; width:100%; height:100%; overflow:hidden; position:relative; box-sizing: border-box; }
                #wrap { display:flex; position:absolute; box-sizing: border-box; width:100%; height:100%; left:0%; transition: left 0.5s; }
                ::slotted(div) { flex:0 0 100%; min-width:0%; }
            </style>
            <div id="wrap">
                <slot></slot>
            </div>
        `;
    }

    firstUpdated() {
        
    }

    showPage(value) {
        var pct = "-" + value + "00%";
        this.shadowRoot.getElementById("wrap").style.left = pct;
    }
}

window.customElements.define("bright-pager", BrightPager);

export class BrightFile extends LitElement {

    static get properties() {
        return {
            _value: { type:String }, 
            files: { type:Array },
            required: { type:Boolean }, 
            placeholder: { type:String }, 
            multiple: { type:Boolean }, 
            accept: { type:String }, 
            name: { type:String }
        }
    }

    constructor(){
        super(); 
        this.accept = "*/*";
        this.multiple = false; 
        this._value = "";
        this.attachShadow({ mode: 'open' });
    }

    render() {
        return html`
           <style>
                :host { display:block; box-sizing:border-box; }
                :host([hidden]) { display:none; }
                ::placeholder { color:var(--body-inverse); opacity:0.5; }
                input { height:36px; width:100%; color:var(--body-inverse); border: 1px solid var(--line-border); padding:8px; box-sizing:border-box; border-radius:2px; box-shadow:none; font-size:var(--body1-size); font-weight:var(--body1-weight); font-family: Roboto, Arial, Helvetica, sans-serif; -webkit-appearance: none; -moz-appearance: none; appearance: none; }
                input:focus { border: 1px solid grey; outline:none; }
                input:invalid { border: 1px solid var(--alert); }
                input[type=file] { display:none; }
                input[type=text] { -webkit-appearance: none; -moz-appearance: none; appearance: none; } /* remove ios inset shadow */
            </style>
            <div>${this._value}</div>
            <input type="text" id="textInput" @click="${this.textInputClick}" placeholder="${this.placeholder ? this.placeholder : ""}" value="${this._value}">
            <input type="file" id="fileInput" name="files" @change="${this.fileInputChange}" accept="${this.accept}" ?multiple="${this.multiple}"/>
        `;
    }

    firstUpdated() {
        this.dispatchEvent(new CustomEvent("bright-validatable", {
            bubbles: true, 
            composed: true
        }));
    }

    textInputClick(e) {
        this.shadowRoot.getElementById("fileInput").click();
        this.blur();
    }

    fileInputChange() {
        let e = this.shadowRoot.getElementById("fileInput");
        if(e.files.length == 0) {
            this._value = "";
            this.files = [];
        } else {
            console.log("files", e.files);
            this._value = Array.from(e.files).map(f => f.name).join();
            this.files = e.files;
        }
    }

    validate() {
        var valid = true; 
        if(this.required && this._value == "") valid = false; 
        this.input.setCustomValidity(valid ? "" : "required field");
        this.input.valid = valid; 
        return valid; 
    }
}
window.customElements.define("bright-file", BrightFile);

export class BrightRadio extends LitElement {

    static get properties() {
        return {
            selected: { type:Boolean }
        }
    }

    constructor() {
        super(); 
        this.selected = false; 
    }

    render() {
        return html`
            <style>
                bright-icon { vertical-align:middle; }
            </style>
            ${ this.selected ? 
                html`<bright-icon icon="radio-button-checked" @click="${this.radioClick}"></bright-icon>` :
                html`<bright-icon icon="radio-button-unchecked" @click="${this.radioClick}"></bright-icon>`
            }
            <slot></slot>
        `;
    }

    firstUpdated() {
        this.dispatchEvent(new CustomEvent("bright-radio-register", { detail:this, composed:true, bubbles:true }));
    }

    radioClick() {
        this.dispatchEvent(new CustomEvent("bright-radio-selected", { detail:this, composed:true, bubbles:true }));
    }
}
window.customElements.define("bright-radio", BrightRadio);


export class BrightRadioGroup extends LitElement {

    static get properties() {
        return {
            selected: { type:Object }, 
            radios: { type:Array }
        }
    }

    constructor() {
        super(); 
        this.radios = [];
        addEventListener("bright-radio-register", e => {
            this.radios.push(e.detail);
        });
        addEventListener("bright-radio-selected", e => {
            let radio = e.detail; 
            this.radios.forEach(r => {
                let selected = (radio == r);
                let changed = r.selected != selected; 
                r.selected = (radio == r);
                if(changed) r.dispatchEvent(new Event("change"));
            });
        })
    }

    render() {
        return html`<slot></slot>`;
    }
}
window.customElements.define("bright-radio-group", BrightRadioGroup);

export class BrightDate extends LitElement {

    static get properties() {
        return {
            value: { type:String }, 
            text: { type:String }
        }
    }

    render() {
        return html`
            <style>
                #hide { display:none; }
            </style>
            <span id="hide"><slot></slot></span>
            <span>${this.text}</span>
        `; 
    }

    firstUpdated() {
        let sdate = this.childNodes[0].textContent;
        console.log("string", sdate);
        let ndate = new Date(sdate);
        console.log("date obj", ndate);
        let formatted = DateUtil.formatWithTime(new Date(sdate));
        console.log("local", formatted);
        this.text = formatted;
    }
}
window.customElements.define("bright-date", BrightDate);

export class BrightSuggest extends LitElement {

    static get properties() {
        return {
            value: { type:String }, 
            required: { type:Boolean }, 
            placeholder: { type:String }, 
            label: { type:String }, 
            password: { type:Boolean },
            type: { type:String }, 
            name: { type:String }, 
            suggestFunc: { type:Object }, 
            suggestions: { type:Array }, 
            loading: { type: Boolean }
        }
    }

    constructor() {
        super();
        this.loading = false; 
    }

    render() {
        return html`
            <style>
                input { height:36px; width:100%; color:var(--body-inverse); border: 1px solid var(--line-border); padding:8px; box-sizing:border-box; border-radius:2px; box-shadow:none; font-size:var(--body1-size); font-weight:var(--body1-weight); font-family: Roboto, Arial, Helvetica, sans-serif; -webkit-appearance: none; -moz-appearance: none; appearance: none; }
                input[type=text] { -webkit-appearance: none; -moz-appearance: none; appearance: none; } /* remove ios inset shadow */
                input:focus { border: 1px solid grey; outline:none; }
                input:invalid { border: 1px solid var(--alert); }
                ::placeholder { color:var(--body-inverse); opacity:0.5; }
                .item { padding:16px; cursor:pointer; }
                .item:hover { background-color:var(--skrim-hover) }
                #wrap { position:relative; }
                #loader { position:absolute; right:8px; top:4px; }
                #notfound { padding: 16px 0px; }
            </style>
            <div id="wrap">
                ${!this.loading ? html`` : html`
                    <svg id="loader" ?hidden="${this.loading}" fill="var(--line-border)" width="24" height="24" viewBox="24 24 50 50">
                        <path  d="M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50">
                        <animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="1s" from="0 50 50"to="360 50 50" repeatCount="indefinite"/>
                        </path>
                    </svg>                
                `}
                <input type="text" id="query" @keyup="${this.keyUp}" name="${this.name}" placeholder="${this.placeholder}"/>
                ${ this.suggestions == undefined ? html`` : html`
                    <div id="dropdown">
                        ${ this.suggestions.map(r => html`
                            <div class="item" .dataitem="${r.value}" @click="${this.itemClick}">${r.key}</div>
                        `)}
                    </div>            
                `}
                <div id="notfound" ?hidden="${!(this.suggestions && this.suggestions.length == 0)}">No Results Found</div>
            </div>
        `; 
    }

    firstUpdated() {
        this.dispatchEvent(new CustomEvent("bright-validatable", {
            bubbles: true, 
            composed: true
        }));
    }

    keyUp() {
        Bouncer.debounce(this, this.change, 1500);
    }

    async change() {
        this.loading = true;
        this.shadowRoot.getElementById("query").valid = true;
        this.value = undefined; 
        let query = this.shadowRoot.getElementById("query").value; 
        let results = await this.suggestFunc(query);
        this.suggestions = results; 
        console.log("results", results);
        this.loading = false; 
    }

    itemClick(e) {
        let key = e.target.innerText; 
        this.shadowRoot.getElementById("query").value = key; 
        this.value = e.target.dataitem; 
        console.log("value", this.value);
        this.suggestions = undefined; 
    }

    validate() {
        var valid = true; 
        if(this.required && this.value == undefined) valid = false; 
        let input = this.shadowRoot.getElementById("query");
        input.setCustomValidity(valid ? "" : "required field");
        input.valid = valid; 
        return valid; 
    }
}

window.customElements.define("bright-suggest", BrightSuggest);
